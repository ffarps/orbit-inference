# Query Templates for Semantic RAG System
# These templates will be embedded and stored in ChromaDB

templates:
  - id: "all_recent_orders"
    version: "1.3.0"
    description: "Show all orders in the last N days"
    nl_examples:
      - "Show orders in the last 7 days"
      - "List all recent orders"
      - "Orders from the past week"
      - "Recent transactions"
    parameters:
      - name: "days_back"
        type: "integer"
        required: false
        default: 7
        description: "Number of days back to look for orders"
        example: 7
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        example: 20
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["recent", "time-bound"]
      intent: "retrieve_all_orders"
    sql_template: |
      SELECT 
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM orders o
      WHERE o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["orders", "recent", "all", "history", "transactions"]
    approved: true

  # CUSTOMER QUERIES
  - id: "customer_recent_orders"
    version: "1.3.0"
    description: "Show recent orders for a specific customer within a time period"
    nl_examples:
      - "What did customer 123 buy last week?"
      - "Show me recent orders for customer John Doe"
      - "List the last 10 orders for customer 42"
      - "What has customer 5 ordered recently?"
      - "Show customer 1's recent activity"
      - "Can you pull up what customer 89 purchased this month?"
      - "I need to see customer 456's latest purchases"
      - "What's been ordered by customer 12 lately?"
      - "Recent shopping history for customer 234"
      - "Display the latest transactions for customer 567"
    negative_examples:
      - "Who are my top customers?"
      - "What is the total revenue from customer 123?"
      - "Show me all customers who ordered recently"
      - "Which customers spend the most?"
      - "Customer lifetime value analysis"
    parameters:
      - name: "customer_id"
        type: "integer"
        required: true
        description: "The ID of the customer"
        aliases: ["client id", "user id", "buyer id", "customer number"]
        example: 123
      - name: "days_back"
        type: "integer"
        required: false
        default: 7
        description: "Number of days back to look for orders"
        aliases: ["time period", "lookback", "recent days", "past days"]
        example: 30
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        aliases: ["max results", "number of results", "how many"]
        example: 10
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["recent", "time-bound", "specific_customer"]
      intent: "retrieve_transaction_history"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE c.id = %(customer_id)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customer", "orders", "recent", "activity", "history", "purchases", "transactions"]
    approved: true

  - id: "customer_orders_by_name"
    version: "1.3.0"
    description: "Show orders for a specific customer by name within a time period"
    nl_examples:
      - "Show me orders from Maria Smith"
      - "Find orders for John Doe"
      - "What did Jessica Johnson order?"
      - "Show orders from customer Anthony Green"
      - "List orders for Teresa Lyons"
      - "Find all orders by Thomas Howell"
      - "I'm looking for purchases made by Sarah Connor"
      - "Can you check what Robert Williams bought?"
      - "Orders placed by Jennifer Lopez please"
      - "Show me everything ordered by Michael Jordan"
      - "What has Jane Smith been buying?"
      - "Pull up David Chen's order history"
    negative_examples:
      - "Find all customers named John"
      - "Show me customer contact information"
      - "Who are customers with similar names?"
      - "Customer search by email"
      - "List all customers in the database"
    parameters:
      - name: "customer_name"
        type: "string"
        required: true
        description: "The name of the customer (partial match)"
        aliases: ["customer", "buyer", "client", "person", "name", "full name"]
        example: "Maria Smith"
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        aliases: ["time period", "lookback", "recent days", "past days"]
        example: 60
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        aliases: ["max results", "number of results", "how many"]
        example: 15
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_name", "time-bound", "specific_customer"]
      intent: "retrieve_transaction_history"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE c.name ILIKE %(customer_name)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customer", "orders", "name", "search", "person", "buyer", "purchaser", "individual", "customer_name"]
    approved: true

  - id: "customer_lifetime_value"
    version: "1.3.0"
    description: "Calculate total lifetime value and statistics for a customer"
    nl_examples:
      - "What's the lifetime value of customer 123?"
      - "How much has customer 456 spent in total?"
      - "Show me the total revenue from customer 89"
      - "Calculate customer 12's lifetime spending"
      - "What's customer 567's total purchase amount?"
      - "How valuable is customer 234 to us?"
      - "Total sales to customer 890"
      - "Customer 345 lifetime statistics"
    negative_examples:
      - "Show me recent orders for customer 123"
      - "What did customer 456 buy last week?"
      - "Customer order history"
      - "Recent customer activity"
      - "Customer's latest purchases"
    parameters:
      - name: "customer_id"
        type: "integer"
        required: true
        description: "The ID of the customer"
        aliases: ["client id", "user id", "buyer id", "customer number"]
        example: 123
    semantic_tags:
      action: "calculate_summary"
      primary_entity: "customer"
      secondary_entity: "order"
      qualifiers: ["lifetime", "total", "aggregate", "statistics"]
      intent: "analyze_customer_value"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        COUNT(DISTINCT o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as lifetime_value,
        COALESCE(AVG(o.total), 0) as avg_order_value,
        COALESCE(MAX(o.total), 0) as largest_order,
        COALESCE(MIN(o.total), 0) as smallest_order,
        MIN(o.order_date) as first_order_date,
        MAX(o.order_date) as last_order_date,
        DATE_PART('day', NOW() - MAX(o.order_date)) as days_since_last_order
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.id = %(customer_id)s
      GROUP BY c.id, c.name, c.email
    result_format: "summary"
    tags: ["customer", "lifetime", "value", "statistics", "revenue", "spending", "total"]
    approved: true

  # ORDER VALUE QUERIES
  - id: "high_value_orders"
    version: "1.3.0"
    description: "Find orders above a certain amount within a time period"
    nl_examples:
      - "Show me all orders over $500 from last month"
      - "Find expensive orders above $1000"
      - "List high-value orders from the last 30 days"
      - "What are the biggest orders recently?"
      - "Show orders worth more than $750"
      - "Which orders exceeded $2000?"
      - "Give me the premium orders over $1500"
      - "Large transactions above $800 please"
      - "Find all big ticket items over $600"
      - "Orders greater than $1200"
      - "Show me purchases exceeding $900"
    negative_examples:
      - "What's the average order value?"
      - "Show me total revenue"
      - "Customer spending analysis"
      - "Order statistics summary"
      - "Revenue breakdown by customer"
    parameters:
      - name: "min_amount"
        type: "decimal"
        required: true
        description: "Minimum order amount to filter by"
        aliases: ["minimum amount", "above", "over", "greater than", "threshold", "minimum value"]
        example: 500.00
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        aliases: ["time period", "lookback", "recent days", "past days"]
        example: 60
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        aliases: ["max results", "number of results", "how many"]
        example: 15
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "amount"
      qualifiers: ["high_value", "above_threshold", "time-bound"]
      intent: "filter_by_amount"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE o.total >= %(min_amount)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.total DESC, o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["orders", "amount", "high_value", "expensive", "premium", "large", "big"]
    approved: true

  - id: "low_value_orders"
    version: "1.3.0"
    description: "Find orders below a certain amount within a time period"
    nl_examples:
      - "Show me all orders under $500 from last month"
      - "Find cheap orders below $100"
      - "List low-value orders from the last 30 days"
      - "What are the smallest orders recently?"
      - "Show orders worth less than $250"
      - "Find all orders below $500 in the last 20 days"
      - "Small purchases under $50"
      - "Budget orders less than $75"
      - "Show me the tiny transactions below $25"
      - "Orders smaller than $150"
      - "Which orders are beneath $200?"
    negative_examples:
      - "What's the average order value?"
      - "Show me total revenue"
      - "Customer spending analysis"
      - "Order statistics summary"
      - "Revenue breakdown by customer"
    parameters:
      - name: "max_amount"
        type: "decimal"
        required: true
        description: "Maximum order amount to filter by"
        aliases: ["maximum amount", "below", "under", "less than", "threshold", "maximum value"]
        example: 500.00
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        aliases: ["time period", "lookback", "recent days", "past days"]
        example: 60
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        aliases: ["max results", "number of results", "how many"]
        example: 15
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "amount"
      qualifiers: ["low_value", "below_threshold", "time-bound"]
      intent: "filter_by_amount"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE o.total < %(max_amount)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.total ASC, o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["orders", "amount", "low_value", "cheap", "small", "budget", "tiny"]
    approved: true

  - id: "orders_in_range"
    version: "1.3.0"
    description: "Find orders within a specific price range"
    nl_examples:
      - "Show orders between $100 and $500"
      - "Find purchases from $50 to $200"
      - "Orders in the $300-$800 range"
      - "What orders fall between $150 and $600?"
      - "Show me mid-range orders $200-$700"
      - "Transactions between $75 and $300 please"
      - "Orders priced from $400 to $1000"
      - "Find orders in the $100 to $250 bracket"
    negative_examples:
      - "Show me all orders"
      - "What's the average order value?"
      - "Order statistics summary"
      - "Revenue breakdown"
      - "Customer spending analysis"
    parameters:
      - name: "min_amount"
        type: "decimal"
        required: true
        description: "Minimum order amount"
        aliases: ["minimum amount", "from", "starting amount", "lower bound"]
        example: 100.00
      - name: "max_amount"
        type: "decimal"
        required: true
        description: "Maximum order amount"
        aliases: ["maximum amount", "to", "ending amount", "upper bound"]
        example: 500.00
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        aliases: ["time period", "lookback", "recent days", "past days"]
        example: 30
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        aliases: ["max results", "number of results", "how many"]
        example: 20
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "amount"
      qualifiers: ["range", "between", "time-bound", "price_range"]
      intent: "filter_by_amount_range"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE o.total >= %(min_amount)s
        AND o.total <= %(max_amount)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.total DESC, o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["orders", "range", "between", "price", "bracket", "mid-range"]
    approved: true

  # STATUS QUERIES
  - id: "orders_by_status"
    version: "1.3.0"
    description: "Find orders with a specific status within a time period"
    nl_examples:
      - "Show me all pending orders"
      - "Find delivered orders from last week"
      - "List cancelled orders from the last month"
      - "What orders are still processing?"
      - "Show shipped orders from yesterday"
      - "Which orders are waiting to be processed?"
      - "Orders that have been delivered"
      - "Show me the cancelled transactions"
      - "What's in pending status?"
      - "Find all shipped packages"
      - "Orders currently being processed"
      - "Show completed deliveries"
    negative_examples:
      - "Show me order status statistics"
      - "What's the most common order status?"
      - "Order status breakdown"
      - "Status distribution analysis"
      - "How many orders are in each status?"
    parameters:
      - name: "status"
        type: "string"
        required: true
        description: "Order status to filter by"
        aliases: ["order status", "state", "condition", "stage", "phase"]
        allowed_values: ["pending", "processing", "shipped", "delivered", "cancelled"]
        example: "delivered"
      - name: "days_back"
        type: "integer"
        required: false
        default: 7
        description: "Number of days back to look for orders"
        aliases: ["time period", "lookback", "recent days", "past days"]
        example: 14
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        aliases: ["max results", "number of results", "how many"]
        example: 25
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "status"
      qualifiers: ["by_status", "time-bound", "filtered"]
      intent: "filter_by_status"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE o.status = %(status)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["orders", "status", "filter", "state", "condition", "stage"]
    approved: true

  - id: "problematic_orders"
    description: "Find orders that might need attention (cancelled or long pending)"
    nl_examples:
      - "Show me problematic orders"
      - "Which orders need attention?"
      - "Find troubled transactions"
      - "Orders that might have issues"
      - "Show cancelled or stuck orders"
      - "What orders are having problems?"
      - "Find orders requiring intervention"
      - "Show me orders that need to be looked at"
      - "Problem orders report"
    parameters:
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        example: 30
      - name: "pending_threshold_days"
        type: "integer"
        required: false
        default: 3
        description: "Days before a pending order is considered problematic"
        example: 3
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at,
        CASE 
          WHEN o.status = 'cancelled' THEN 'Cancelled Order'
          WHEN o.status = 'pending' AND o.created_at < NOW() - make_interval(days => %(pending_threshold_days)s) THEN 'Long Pending'
          ELSE 'Other Issue'
        END as issue_type
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE o.created_at >= NOW() - make_interval(days => %(days_back)s)
        AND (
          o.status = 'cancelled' 
          OR (o.status = 'pending' AND o.created_at < NOW() - make_interval(days => %(pending_threshold_days)s))
        )
      ORDER BY o.created_at DESC
    result_format: "table"
    tags: ["orders", "problems", "issues", "attention", "cancelled", "stuck", "troubled"]
    approved: true

  # SUMMARY QUERIES
  - id: "customer_summary"
    version: "1.3.0"
    description: "Get a summary of customer order statistics"
    nl_examples:
      - "Give me a summary for customer 123"
      - "What's the total spent by customer John Doe?"
      - "Show customer 5's order history summary"
      - "How much has customer 42 spent in total?"
      - "Customer summary for ID 10"
      - "Quick stats on customer 789"
      - "Overview of customer 234's activity"
      - "Summarize customer 567's purchases"
      - "Customer 890 at a glance"
      - "Profile summary for customer 345"
    negative_examples:
      - "Show me recent orders for customer 123"
      - "What did customer 456 buy last week?"
      - "Customer order details"
      - "Individual order information"
      - "Customer's latest purchases"
    parameters:
      - name: "customer_id"
        type: "integer"
        required: true
        description: "The ID of the customer"
        aliases: ["client id", "user id", "buyer id", "customer number"]
        example: 123
      - name: "days_back"
        type: "integer"
        required: false
        default: 365
        description: "Number of days back to include in summary"
        aliases: ["time period", "lookback", "recent days", "past days", "summary period"]
        example: 90
    semantic_tags:
      action: "calculate_summary"
      primary_entity: "customer"
      secondary_entity: "order"
      qualifiers: ["summary", "statistics", "overview", "time-bound"]
      intent: "analyze_customer_activity"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent,
        COALESCE(AVG(o.total), 0) as avg_order_value,
        MIN(o.order_date) as first_order_date,
        MAX(o.order_date) as last_order_date,
        STRING_AGG(DISTINCT o.status, ', ') as order_statuses
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      WHERE c.id = %(customer_id)s
      GROUP BY c.id, c.name, c.email
    result_format: "summary"
    tags: ["customer", "summary", "statistics", "analytics", "overview", "profile"]
    approved: true

  - id: "daily_sales_summary"
    description: "Get sales summary for a specific date or date range"
    # SECURITY: Uses make_interval() for safe parameterized interval handling
    nl_examples:
      - "What were yesterday's sales?"
      - "Show me today's revenue"
      - "Sales summary for last Monday"
      - "How much did we sell on 2024-12-25?"
      - "Daily sales report for this week"
      - "What's our revenue today?"
      - "Show sales for December 15th"
      - "Yesterday's sales figures"
      - "How did we do last Friday?"
      - "Sales total for the 20th"
    parameters:
      - name: "target_date"
        type: "date"
        required: false
        default: "TODAY"
        description: "Specific date for sales summary (defaults to today)"
        example: "2024-12-25"
      - name: "days_range"
        type: "integer"
        required: false
        default: 1
        description: "Number of days to include in summary"
        example: 7
    sql_template: |
      SELECT 
        DATE(o.order_date) as sale_date,
        COUNT(DISTINCT o.id) as total_orders,
        COUNT(DISTINCT o.customer_id) as unique_customers,
        SUM(o.total) as total_revenue,
        AVG(o.total) as avg_order_value,
        MAX(o.total) as largest_order,
        MIN(o.total) as smallest_order
      FROM orders o
      WHERE o.order_date >= COALESCE(
        CASE 
          WHEN %(target_date)s = 'TODAY' THEN CURRENT_DATE
          WHEN %(target_date)s = 'YESTERDAY' THEN CURRENT_DATE - make_interval(days => 1)
          ELSE %(target_date)s::DATE
        END, CURRENT_DATE) - make_interval(days => %(days_range)s)
        AND o.order_date <= COALESCE(
        CASE 
          WHEN %(target_date)s = 'TODAY' THEN CURRENT_DATE
          WHEN %(target_date)s = 'YESTERDAY' THEN CURRENT_DATE - make_interval(days => 1)
          ELSE %(target_date)s::DATE
        END, CURRENT_DATE)
      GROUP BY DATE(o.order_date)
      ORDER BY sale_date DESC
    result_format: "summary"
    tags: ["sales", "daily", "revenue", "summary", "report", "today", "yesterday"]
    approved: true

  # LOCATION QUERIES
  - id: "orders_by_city"
    description: "Find orders from customers in a specific city"
    nl_examples:
      - "Show orders from New York customers"
      - "Find orders from customers in Los Angeles"
      - "What orders came from Chicago?"
      - "Orders from San Francisco customers"
      - "Show me orders from Boston"
      - "Which customers from Seattle ordered?"
      - "Dallas customer orders"
      - "Find Miami purchases"
      - "Orders originating from Denver"
      - "Show Houston customer transactions"
      - "Portland buyer orders"
      - "Show orders from Toronto customers"
      - "Orders from Vancouver customers"
      - "Find orders from Montreal customers"
      - "Show me Calgary customer orders"
      - "Orders from Ottawa customers"
    parameters:
      - name: "city"
        type: "string"
        required: true
        description: "City name to filter by (partial match)"
        example: "New York"
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        example: 60
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        example: 15
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE c.city ILIKE %(city)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customer", "orders", "city", "location", "geographic", "place"]
    approved: true

  - id: "orders_by_country"
    description: "Find orders from customers in a specific country"
    nl_examples:
      - "Show orders from USA"
      - "Canadian customer orders"
      - "What did UK customers buy?"
      - "Orders from customers in France"
      - "Show German customer purchases"
      - "Find all orders from Australia"
      - "Mexican customer transactions"
      - "Orders coming from Japan"
      - "Show me Brazil purchases"
      - "Indian customer orders please"
      - "Orders from customers in Canada"
      - "Canadian customer transactions"
      - "Show me Canadian orders"
    parameters:
      - name: "country"
        type: "string"
        required: true
        description: "Country name to filter by (partial match)"
        example: "United States"
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        example: 90
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        example: 25
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.country as customer_country,
        c.city as customer_city,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE c.country ILIKE %(country)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customer", "orders", "country", "location", "international", "global"]
    approved: true

  # PAYMENT METHOD QUERIES
  - id: "payment_method_analysis"
    version: "1.3.0"
    description: "Analyze orders by payment method"
    nl_examples:
      - "Show me orders paid with credit card"
      - "Find PayPal orders from last month"
      - "What orders used bank transfer?"
      - "Show cash payments"
      - "Credit card orders analysis"
      - "How many debit card transactions?"
      - "Orders paid via PayPal"
      - "Bank transfer purchases"
      - "Show me all cash sales"
      - "Which orders used credit cards?"
      - "Payment by debit card"
    negative_examples:
      - "Show me payment method statistics"
      - "What's the most popular payment method?"
      - "Payment method breakdown"
      - "Payment preference analysis"
      - "How do customers prefer to pay?"
    parameters:
      - name: "payment_method"
        type: "string"
        required: true
        description: "Payment method to filter by"
        aliases: ["payment type", "payment option", "how paid", "payment", "method"]
        allowed_values: ["credit_card", "debit_card", "paypal", "bank_transfer", "cash"]
        example: "credit_card"
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        aliases: ["time period", "lookback", "recent days", "past days"]
        example: 90
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        aliases: ["max results", "number of results", "how many"]
        example: 25
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "payment_method"
      qualifiers: ["by_payment_method", "time-bound", "filtered"]
      intent: "filter_by_payment"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE o.payment_method = %(payment_method)s
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["orders", "payment", "analysis", "method", "paid", "transaction"]
    approved: true

  - id: "payment_method_summary"
    description: "Summary of payment methods usage and revenue"
    nl_examples:
      - "Payment method breakdown"
      - "How are customers paying?"
      - "Payment type analysis"
      - "Show payment method statistics"
      - "Which payment methods are most popular?"
      - "Payment preference summary"
      - "Revenue by payment type"
      - "Payment method distribution"
      - "How much revenue per payment method?"
    parameters:
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to analyze"
        example: 90
    sql_template: |
      SELECT 
        o.payment_method,
        COUNT(DISTINCT o.id) as order_count,
        COUNT(DISTINCT o.customer_id) as unique_customers,
        SUM(o.total) as total_revenue,
        AVG(o.total) as avg_order_value,
        ROUND((COUNT(*)::numeric / (SELECT COUNT(*) FROM orders WHERE created_at >= NOW() - make_interval(days => %(days_back)s))) * 100, 2) as percentage_of_orders
      FROM orders o
      WHERE o.created_at >= NOW() - make_interval(days => %(days_back)s)
      GROUP BY o.payment_method
      ORDER BY total_revenue DESC
    result_format: "summary"
    tags: ["payment", "summary", "statistics", "breakdown", "analysis", "revenue"]
    approved: true

  # TRENDING AND ANALYTICS QUERIES
  - id: "top_customers"
    version: "1.3.0"
    description: "Find top customers by total spending or order count"
    nl_examples:
      - "Who are our top 10 customers?"
      - "Show me the biggest spenders"
      - "Which customers order the most?"
      - "Top customers by revenue"
      - "Best customers list"
      - "Who spends the most money?"
      - "Highest value customers"
      - "VIP customer list"
      - "Show our most valuable customers"
      - "Top 20 buyers"
    negative_examples:
      - "Show me recent orders for customer 123"
      - "What did customer 456 buy last week?"
      - "Customer order details"
      - "Individual customer analysis"
      - "Customer's latest purchases"
    parameters:
      - name: "metric"
        type: "string"
        required: false
        default: "spending"
        description: "Metric to rank by"
        aliases: ["ranking metric", "sort by", "order by", "measure", "criteria"]
        allowed_values: ["spending", "order_count"]
        example: "spending"
      - name: "days_back"
        type: "integer"
        required: false
        default: 90
        description: "Number of days back to analyze"
        aliases: ["time period", "lookback", "recent days", "past days", "analysis period"]
        example: 180
      - name: "limit"
        type: "integer"
        required: false
        default: 10
        description: "Number of top customers to return"
        aliases: ["max results", "number of results", "how many", "top n"]
        example: 20
    semantic_tags:
      action: "rank_list"
      primary_entity: "customer"
      secondary_entity: "order"
      qualifiers: ["top", "ranking", "best", "time-bound"]
      intent: "identify_best_customers"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city,
        c.country,
        COUNT(DISTINCT o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent,
        COALESCE(AVG(o.total), 0) as avg_order_value,
        MAX(o.order_date) as last_order_date
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
        AND o.created_at >= NOW() - make_interval(days => %(days_back)s)
      GROUP BY c.id, c.name, c.email, c.city, c.country
      HAVING COUNT(o.id) > 0
      ORDER BY 
        CASE 
          WHEN %(metric)s = 'spending' THEN COALESCE(SUM(o.total), 0)
          WHEN %(metric)s = 'order_count' THEN COUNT(DISTINCT o.id)::numeric
        END DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customers", "top", "best", "valuable", "VIP", "ranking", "leaders"]
    approved: true

  - id: "recent_new_customers"
    description: "Find customers who made their first order recently"
    nl_examples:
      - "Show me new customers from this week"
      - "Who are our newest customers?"
      - "Recent first-time buyers"
      - "New customer acquisitions"
      - "First-time purchasers this month"
      - "Latest customer signups with orders"
      - "Who just started buying from us?"
      - "Fresh customers list"
      - "Newly acquired buyers"
    parameters:
      - name: "days_back"
        type: "integer"
        required: false
        default: 7
        description: "Number of days back to look for new customers"
        example: 30
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        example: 50
    sql_template: |
      WITH first_orders AS (
        SELECT 
          customer_id,
          MIN(order_date) as first_order_date,
          MIN(created_at) as first_order_created
        FROM orders
        GROUP BY customer_id
      )
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city,
        c.country,
        fo.first_order_date,
        o.id as first_order_id,
        o.total as first_order_amount,
        o.payment_method as first_payment_method
      FROM customers c
      INNER JOIN first_orders fo ON c.id = fo.customer_id
      INNER JOIN orders o ON c.id = o.customer_id 
        AND o.order_date = fo.first_order_date
      WHERE fo.first_order_created >= NOW() - make_interval(days => %(days_back)s)
      ORDER BY fo.first_order_created DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customers", "new", "recent", "first-time", "acquisition", "fresh"]
    approved: true

  - id: "order_trends"
    description: "Analyze order trends over time periods"
    nl_examples:
      - "Show me order trends this month"
      - "How are sales trending?"
      - "Order volume over the last 30 days"
      - "Daily order patterns"
      - "Sales trend analysis"
      - "Are orders increasing or decreasing?"
      - "Show order growth"
      - "Transaction volume trends"
      - "Order frequency patterns"
    parameters:
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to analyze"
        example: 60
      - name: "group_by"
        type: "string"
        required: false
        default: "day"
        description: "Time period to group by"
        allowed_values: ["day", "week", "month"]
        example: "week"
    sql_template: |
      SELECT 
        CASE 
          WHEN %(group_by)s = 'day' THEN DATE(o.order_date)::text
          WHEN %(group_by)s = 'week' THEN DATE_TRUNC('week', o.order_date)::date::text
          WHEN %(group_by)s = 'month' THEN DATE_TRUNC('month', o.order_date)::date::text
        END as period,
        COUNT(DISTINCT o.id) as order_count,
        COUNT(DISTINCT o.customer_id) as unique_customers,
        SUM(o.total) as total_revenue,
        AVG(o.total) as avg_order_value
      FROM orders o
      WHERE o.created_at >= NOW() - make_interval(days => %(days_back)s)
      GROUP BY 1
      ORDER BY 1 DESC
    result_format: "table"
    tags: ["orders", "trends", "analytics", "patterns", "growth", "volume", "frequency"]
    approved: true

  # SEARCH QUERIES
  - id: "search_customer_email"
    version: "1.3.0"
    description: "Find customers by email address"
    nl_examples:
      - "Find customer with email john@example.com"
      - "Search for user@gmail.com"
      - "Who has the email address sarah@company.com?"
      - "Customer with email mike@domain.org"
      - "Look up buyer@email.net"
      - "Find the customer using admin@site.com"
      - "Email search for contact@business.com"
    negative_examples:
      - "Show me all customer emails"
      - "Email address statistics"
      - "Customer contact information"
      - "Email domain analysis"
      - "Customer email distribution"
    parameters:
      - name: "email"
        type: "string"
        required: true
        description: "Email address to search for (partial match)"
        aliases: ["email address", "email address", "contact email", "user email", "customer email"]
        example: "john@example.com"
    semantic_tags:
      action: "search_find"
      primary_entity: "customer"
      secondary_entity: "email"
      qualifiers: ["by_email", "search", "lookup"]
      intent: "find_customer_by_contact"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.phone,
        c.city,
        c.country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as lifetime_value
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.email ILIKE %(email)s
      GROUP BY c.id, c.name, c.email, c.phone, c.city, c.country, c.created_at
    result_format: "summary"
    tags: ["customer", "search", "email", "find", "lookup", "contact"]
    approved: true

  - id: "inactive_customers"
    description: "Find customers who haven't ordered in a while"
    nl_examples:
      - "Show inactive customers"
      - "Who hasn't ordered in 90 days?"
      - "Find dormant customers"
      - "Customers not buying recently"
      - "Show me who stopped ordering"
      - "Lapsed customer list"
      - "Which customers went quiet?"
      - "Customers we're losing"
      - "Who needs re-engagement?"
    parameters:
      - name: "inactive_days"
        type: "integer"
        required: false
        default: 90
        description: "Days without orders to consider inactive"
        example: 60
      - name: "min_previous_orders"
        type: "integer"
        required: false
        default: 1
        description: "Minimum previous orders to be considered"
        example: 2
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        example: 30
    sql_template: |
      WITH customer_last_order AS (
        SELECT 
          customer_id,
          MAX(order_date) as last_order_date,
          COUNT(*) as total_orders,
          SUM(total) as lifetime_value
        FROM orders
        GROUP BY customer_id
        HAVING COUNT(*) >= %(min_previous_orders)s
      )
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        clo.last_order_date,
        DATE_PART('day', NOW() - clo.last_order_date) as days_inactive,
        clo.total_orders,
        clo.lifetime_value
      FROM customers c
      INNER JOIN customer_last_order clo ON c.id = clo.customer_id
      WHERE clo.last_order_date < NOW() - make_interval(days => %(inactive_days)s)
      ORDER BY clo.lifetime_value DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customers", "inactive", "dormant", "lapsed", "retention", "churn"]
    approved: true

  # INTERNATIONAL SHIPPING QUERIES
  - id: "international_orders"
    version: "1.3.0"
    description: "Find orders shipped to international destinations"
    nl_examples:
      - "Show orders shipped to the United States"
      - "Orders delivered to European countries"
      - "International orders over $200"
      - "Shipping to Asian countries"
      - "Canadian customers shipping abroad"
      - "Orders with international shipping addresses"
      - "Show me international shipments"
      - "Orders shipped outside Canada"
      - "International delivery orders"
      - "Cross-border orders"
    negative_examples:
      - "Show me domestic orders"
      - "Local shipping analysis"
      - "Domestic delivery statistics"
      - "Local order breakdown"
      - "In-country shipping analysis"
    parameters:
      - name: "destination_country"
        type: "string"
        required: false
        description: "Specific destination country to filter by"
        aliases: ["country", "destination", "shipping country", "target country"]
        example: "United States"
      - name: "min_amount"
        type: "decimal"
        required: false
        description: "Minimum order amount for international orders"
        aliases: ["minimum amount", "above", "over", "greater than", "threshold"]
        example: 200.00
      - name: "days_back"
        type: "integer"
        required: false
        default: 30
        description: "Number of days back to look for orders"
        aliases: ["time period", "lookback", "recent days", "past days"]
        example: 60
      - name: "limit"
        type: "integer"
        required: false
        default: 20
        description: "Maximum number of results to return"
        aliases: ["max results", "number of results", "how many"]
        example: 25
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "shipping"
      qualifiers: ["international", "cross_border", "time-bound", "optional_amount_filter"]
      intent: "analyze_international_sales"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        o.id as order_id,
        o.order_date,
        o.total,
        o.status,
        o.payment_method,
        o.shipping_address,
        o.created_at
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE o.created_at >= NOW() - make_interval(days => %(days_back)s)
        AND o.shipping_address ILIKE '%Canada%'
        AND (
          %(destination_country)s IS NULL 
          OR o.shipping_address ILIKE %(destination_country)s
        )
        AND (
          %(min_amount)s IS NULL 
          OR o.total >= %(min_amount)s
        )
      ORDER BY o.created_at DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["orders", "international", "shipping", "destination", "cross-border", "global"]
    approved: true

  - id: "revenue_by_shipping_destination"
    description: "Analyze revenue by shipping destination country"
    nl_examples:
      - "Revenue by shipping destination"
      - "Which countries order the most?"
      - "Sales by destination country"
      - "International revenue breakdown"
      - "Revenue from different countries"
      - "Sales performance by region"
      - "Which markets are most profitable?"
      - "Revenue analysis by shipping location"
      - "International sales summary"
    parameters:
      - name: "days_back"
        type: "integer"
        required: false
        default: 90
        description: "Number of days back to analyze"
        example: 180
      - name: "min_revenue"
        type: "decimal"
        required: false
        description: "Minimum revenue threshold to include"
        example: 1000.00
    sql_template: |
      SELECT 
        CASE 
          WHEN o.shipping_address ILIKE '%United States%' THEN 'United States'
          WHEN o.shipping_address ILIKE '%United Kingdom%' THEN 'United Kingdom'
          WHEN o.shipping_address ILIKE '%Germany%' THEN 'Germany'
          WHEN o.shipping_address ILIKE '%France%' THEN 'France'
          WHEN o.shipping_address ILIKE '%Japan%' THEN 'Japan'
          WHEN o.shipping_address ILIKE '%Australia%' THEN 'Australia'
          WHEN o.shipping_address ILIKE '%Spain%' THEN 'Spain'
          WHEN o.shipping_address ILIKE '%Italy%' THEN 'Italy'
          WHEN o.shipping_address ILIKE '%South Korea%' THEN 'South Korea'
          WHEN o.shipping_address ILIKE '%Canada%' THEN 'Canada'
          ELSE 'Other'
        END as destination_country,
        COUNT(DISTINCT o.id) as order_count,
        COUNT(DISTINCT o.customer_id) as unique_customers,
        SUM(o.total) as total_revenue,
        AVG(o.total) as avg_order_value,
        ROUND((COUNT(*)::numeric / (SELECT COUNT(*) FROM orders WHERE created_at >= NOW() - make_interval(days => %(days_back)s))) * 100, 2) as percentage_of_orders
      FROM orders o
      WHERE o.created_at >= NOW() - make_interval(days => %(days_back)s)
        AND (
          %(min_revenue)s IS NULL 
          OR SUM(o.total) >= %(min_revenue)s
        )
      GROUP BY 1
      HAVING COUNT(*) > 0
      ORDER BY total_revenue DESC
    result_format: "summary"
    tags: ["revenue", "international", "shipping", "destination", "country", "analysis", "global"]
    approved: true

  - id: "international_payment_methods"
    description: "Analyze payment methods used for international orders"
    nl_examples:
      - "International payment methods used"
      - "How do international customers pay?"
      - "Payment methods by country"
      - "Cross-border payment analysis"
      - "International transaction methods"
      - "Payment preferences by region"
      - "Which payment methods work internationally?"
      - "Global payment method breakdown"
    parameters:
      - name: "days_back"
        type: "integer"
        required: false
        default: 90
        description: "Number of days back to analyze"
        example: 180
      - name: "destination_country"
        type: "string"
        required: false
        description: "Specific destination country to filter by"
        example: "United States"
    sql_template: |
      SELECT 
        o.payment_method,
        CASE 
          WHEN o.shipping_address ILIKE '%United States%' THEN 'United States'
          WHEN o.shipping_address ILIKE '%United Kingdom%' THEN 'United Kingdom'
          WHEN o.shipping_address ILIKE '%Germany%' THEN 'Germany'
          WHEN o.shipping_address ILIKE '%France%' THEN 'France'
          WHEN o.shipping_address ILIKE '%Japan%' THEN 'Japan'
          WHEN o.shipping_address ILIKE '%Australia%' THEN 'Australia'
          WHEN o.shipping_address ILIKE '%Spain%' THEN 'Spain'
          WHEN o.shipping_address ILIKE '%Italy%' THEN 'Italy'
          WHEN o.shipping_address ILIKE '%South Korea%' THEN 'South Korea'
          WHEN o.shipping_address ILIKE '%Canada%' THEN 'Canada'
          ELSE 'Other'
        END as destination_country,
        COUNT(DISTINCT o.id) as order_count,
        SUM(o.total) as total_revenue,
        AVG(o.total) as avg_order_value
      FROM orders o
      WHERE o.created_at >= NOW() - make_interval(days => %(days_back)s)
        AND (
          %(destination_country)s IS NULL 
          OR o.shipping_address ILIKE %(destination_country)s
        )
      GROUP BY o.payment_method, 2
      ORDER BY destination_country, total_revenue DESC
    result_format: "table"
    tags: ["payment", "international", "methods", "cross-border", "global", "analysis"]
    approved: true

  - id: "repeat_customers"
    description: "Find all customers who have placed more than one order (repeat customers)"
    nl_examples:
      - "Show me repeat customers"
      - "List customers who ordered more than once"
      - "Who are our returning customers?"
      - "Find customers with multiple orders"
      - "Repeat buyers"
    parameters:
      - name: "min_orders"
        type: "integer"
        required: false
        default: 2
        description: "Minimum number of orders to be considered a repeat customer"
        example: 2
      - name: "days_back"
        type: "integer"
        required: false
        default: 365
        description: "Number of days back to look for orders"
        example: 365
      - name: "limit"
        type: "integer"
        required: false
        default: 50
        description: "Maximum number of results to return"
        example: 50
    sql_template: |
      SELECT
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city,
        c.country,
        COUNT(o.id) as order_count,
        MIN(o.order_date) as first_order_date,
        MAX(o.order_date) as last_order_date
      FROM customers c
      INNER JOIN orders o ON c.id = o.customer_id
      WHERE o.created_at >= NOW() - make_interval(days => %(days_back)s)
      GROUP BY c.id, c.name, c.email, c.city, c.country
      HAVING COUNT(o.id) >= %(min_orders)s
      ORDER BY order_count DESC, last_order_date DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customers", "repeat", "returning", "multiple orders", "retention"]
    approved: true